# -*- coding: utf-8 -*-
"""AI037-CHETAN-DAA AAT

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RwX3XdXAYKZmOxurqjMvwh6cn4_cW30l
"""

#1-KNAPSACK
import sys

def unboundedKnapsack(k, arr):
    dp = [0] * (k + 1)
    for i in range(1, k + 1):
        for num in arr:
            if num <= i:
                dp[i] = max(dp[i], dp[i - num] + num)
    return dp[k]

if __name__ == '__main__':
    # Read number of test cases
    t = int(input().strip())
    results = []

    # Process each test case
    for _ in range(t):
        n, k = map(int, input().strip().split())
        arr = list(map(int, input().strip().split()))
        results.append(unboundedKnapsack(k, arr))

    # Print results directly (Colab doesn't support writing to files via environment variables like 'OUTPUT_PATH')
    for result in results:
        print(result)



#cloudy day
import math
import os
import random
import re
import sys

from collections import defaultdict


def maximumPeople(towns, cloud_start, cloud_end):
    towns = sorted(towns)
    cloud_start = sorted(cloud_start)
    cloud_end = sorted(cloud_end)

    cloud_start_i = 0
    cloud_end_i = 0
    clouds = set()

    d = defaultdict(int)
    free = 0
    for town_i in range(len(towns)):
        town_x = towns[town_i][0]
        while cloud_start_i < len(cloud_start) and cloud_start[cloud_start_i][0] <= town_x:
            clouds.add(cloud_start[cloud_start_i][1])
            cloud_start_i += 1
        while cloud_end_i < len(cloud_end) and cloud_end[cloud_end_i][0] < town_x:
            clouds.remove(cloud_end[cloud_end_i][1])
            cloud_end_i += 1
        if len(clouds) == 1:
            towns[town_i][2] = list(clouds)[0]
            d[list(clouds)[0]] += towns[town_i][1]
        elif len(clouds) == 0:
            free += towns[town_i][1]

    return max(d.values(), default=0) + free


def main():
    n = int(input().strip())
    p = [int(x) for x in input().strip().split()]
    x = [int(x) for x in input().strip().split()]
    towns = [[xi, pi, -1] for xi, pi in zip(x, p)]
    m = int(input().strip())
    y = [int(x) for x in input().strip().split()]
    r = [int(x) for x in input().strip().split()]
    cloud_start = [[y[i]-r[i], i] for i in range(m)]
    cloud_end = [[y[i]+r[i], i] for i in range(m)]
    result = maximumPeople(towns, cloud_start, cloud_end)
    print(result)

if __name__ == "__main__":
    main()

#quicksort
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[0]
    left = [x for x in arr[1:] if x < pivot]
    mid = [x for x in arr if x == pivot]
    right = [x for x in arr[1:] if x > pivot]
    return quicksort(left) + mid + quicksort(right)

n = int(input())
arr = list(map(int, input().split()))
ans = quicksort(arr)

for num in ans:
    print(num, end=' ')

n = int(input("Enter the number of strings: "))
for _ in range(n):
    input_str = input("Enter a string: ")
    visited = set()
    cost = 0
    for char in input_str:
        if char not in visited:
            cost += 1
            visited.add(char)
    print("Cost of uniqueness:", cost)

